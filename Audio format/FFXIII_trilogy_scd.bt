//----------------------------------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: FFXIII_trilogy_scd.bt
//   Authors: Surihix
//   Version: 1.3
//   Purpose: Parse FF13 trilogy's SCD files
//  Category: FF13 trilogy SCD files
// File Mask: *.scd
//  ID Bytes: 53 45 44 42 53 53 43 46
//   History: 
//   1.0   2023-07-23 Surihix: Initial version
//   1.2   2023-07-29 Surihx: Updated offset names
//   1.3   2023-07-30 Surihix: Added support for 13-2 & LR's XOR'ed header
//----------------------------------------------------------------------------

struct FILE
{
    char magic[8]<name="Header">;
    Assert(magic == "SEDBSSCF");

    uint32 headerVal1<hidden=true>;
    Assert(headerVal1 == 3);

    FSeek(16);
    uint32 scdSize<name="SCD Size">;

    FSeek(48);
    uint16 unkAchunkCount<name="Number of Unk-A chunks">;
    uint16 unkBchunkCount<name="Number of Unk-B chunks">;
    uint16 soundStreamCount<name="Number of stream info offsets">;
    uint16 soundFolderId<name="Numbered sound folder id">;
    uint32 unkBchunkTableOffset<name="Unk-B Chunk Table start">;
    uint32 infoTableOffset<name="Info Table start">;

    local uint a = 0;
    local uint unkAchunkSeek = 80;
    for(a = 0; a < unkAchunkCount; a++)
    {
        FSeek(unkAchunkSeek);
        struct UNKACHUNK
        {
            uint32 unkAChunkStart<name="Chunk A start">;
            FSeek(unkAChunkStart); 
            uint32 unkA1<hidden=true>;
            uint32 unkA2<hidden=true>;
            float scdVolume<name="SCD Volume">;
            uint32 scdFileNumber<name="SCD File number (only for vorbis type)">;
            uint32 unkA4<hidden=true>;
            unkAchunkSeek += 4;
        }unkAchunk<name="UnkA Chunk offset">;
    }    


    local uint i = 0;
    local uint infoTableSeek = infoTableOffset;    
    for(i = 0; i < soundStreamCount; i++)
    {
        FSeek(infoTableSeek);
        struct INFOTABLE
        {
            uint32 infoOffset<name="Info Section offset">;
            FSeek(infoOffset);
            uint32 streamSize<name="Audio Stream size (0 = No audio stream)">;
            uint32 channelCount<name="Audio Channels (1, 2, & 4)">;
            uint32 sampleRate<name="Audio SampleRate (44000 to 48000 hz)">;
            uint32 formatFlag<name="Audio Format flag (6 = Vorbis & 12 = ADPCM)">;
            uint32 loopStart<name="Audio Loop Start (byte position)">;
            uint32 loopEnd<name="Audio Loop End (byte position)">;
            uint32 metaDataEncoderXORSize<name="MetaData/Encoder/XOR chunk size">;

            FSeek(infoOffset + 32);
            uint16 encryptionFlagCheck<hidden=true>;            
            
            if(encryptionFlagCheck == 8194)
            {
               FSeek(infoOffset + 32);
               uint16 encryptionFlag<name="Encryption flag (8194 = valid encryption flag)">;   
               ubyte unXORmagicNum<name="UnXOR magic number">;
               
               FSeek(infoOffset + 48);
               uint32 oggPageTableSize<name="Ogg page table size">;
               uint32 vorbisHeaderSize<name="Vorbis header size (also applies for XOR'ed data)">;
               
               FSeek(infoOffset + 64);
               char oggPageTable[oggPageTableSize]<name="Ogg page table">;
               char vorbisHeader[vorbisHeaderSize]<name="XOR'ed vorbis header">;
            }
            else
            {
               FSeek(infoOffset + 32);
               char metaDataEncoderXORData[metaDataEncoderXORSize]<name="MetaData/Encoder/XOR chunk">;
            }
                        
            FSeek(infoOffset + 32 + metaDataEncoderXORSize);
            char streamData[streamSize]<name="Audio Stream">;
            
            infoTableSeek += 4;          
        }InfoTable<name="Audio Stream Info offset">;
    }
}File<open=true, name="FF13 SCD">;

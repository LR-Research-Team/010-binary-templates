//---------------------------------------------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: SCD_win32.bt
//   Authors: Surihix
//   Version: 1.6
//   Purpose: Parse FF13 trilogy's SCD files
//  Category: FF13 trilogy SCD files
// File Mask: *.scd
//  ID Bytes: 53 45 44 42 53 53 43 46
//   History: 
//   1.0   2023-07-23 Surihix: Initial version
//   1.2   2023-07-29 Surihx: Updated offset names
//   1.3   2023-07-30 Surihix: Added support for 13-2 & LR's XOR'ed header
//   1.4   2023-08-05 Surihix: Added ADPCM Partial Header offsets and minor fixes
//   1.5   2023-08-09 Surihix: Updated data types for few variables
//   1.6   2024-01-25 Surihix: Updated few offsets and discovered new chunk tables
//---------------------------------------------------------------------------------------

LittleEndian();

struct FILE
{
    char magic[8]<name="Header">;
    Assert(magic == "SEDBSSCF");

    uint32 unkHeaderVal1<name="Unknown HeaderValue_1">;
    Assert(unkHeaderVal1 == 3);
    
    char unkHeaderVal2[2]<name="Unknown HeaderValues_2">;
    
    uint16 unkHeaderVal3<name="Unknown HeaderValue_3">;    

    uint64 scdSize<name="SCD Size">;

    char reserved[24]<name="Reserved, always null">;

    uint16 chunkAcount<name="Number of 'A' chunks">;
    uint16 chunkBcount<name="Number of 'B' chunks">;
    uint16 streamInfoCount<name="Number of 'Stream-info' chunks">;
    uint16 soundFolderId<name="Numbered sound folder id">;

    uint32 chunkBtableOffset<name="'Chunk-B' table offset">;
    uint32 streamInfoTableOffset<name="'Stream-info' table offset">;
    uint32 chunkCtableOffset<name="'Chunk-C' table offset">;

    char reserved2[4]<name="Reserved, always null">;

    uint32 chunkDtableOffset<name="'Chunk-D' table offset">;
    uint16 scdFileNumberMulti<name="SCD File number", comment="sometimes present when there are multiple streams">;


    local uint a = 0;
    local uint chunkAseek = 80;
    for(a = 0; a < chunkAcount; a++)
    {
        FSeek(chunkAseek);
        struct CHUNKA
        {
            uint32 chunkAstart<name="'Chunk-A' start">;
            FSeek(chunkAstart);
             
            char chunkA_unk1[3]<name="UnknownValues_1">;

            ubyte switchingTracksFlag<name="Switching Tracks Flag", comment="1 = Normal-track & 11 = SwitchingType-tracks">;

            uint32 chunkA_unk2<name="UnknownValue_2">;

            float scdVolume<name="SCD Volume">;

            uint16 scdFileNumber<name="SCD File number", comment="sometimes not present if there are multiple streams">;
            uint16 chunkA_unk3<name="UnknownValue_3">;
			
            chunkAseek += 4;

        }chunkA<name="'Chunk-A'">;
    }


    local uint b = 0;
    local uint chunkBseek = chunkBtableOffset;
    for(b = 0; b < chunkBcount; b++)
    {
        FSeek(chunkBseek);
        struct CHUNKB
        {
            uint32 chunkBstart<name="'Chunk-B' start">;

            FSeek(chunkBstart);            
            uint16 chunkB_unk1<name="uint16_UnknownValue_1">;
         
            chunkBseek += 4;

        }chunkB<name="'Chunk-B'">;
    }     


    local uint s = 0;
    local uint streamInfoSeek = streamInfoTableOffset;    
    for(s = 0; s < streamInfoCount; s++)
    {
        FSeek(streamInfoSeek);
        struct STREAMINFO
        {
            uint32 streamInfoStart<name="'Stream-info' start">;

            FSeek(streamInfoStart);
            uint32 streamSize<name="Audio Stream size", comment="0 = No audio stream">;

            if(streamSize != 0)
            {
                uint32 channelCount<name="Audio Channels ", comment="can be 1, 2, & 4">;
                uint32 sampleRate<name="Audio SampleRate">;
                uint32 formatFlag<name="Audio Format flag", comment="6 = Vorbis & 12 = ADPCM">;
                uint32 loopStart<name="Audio Loop Start (byte position)">;
                uint32 loopEnd<name="Audio Loop End (byte position)">;
                uint32 partialHeaderXORSize<name="PartialHeader/XOR chunk size">;
                
                FSeek(streamInfoStart + 32);
                uint16 encryptionFlagCheck<hidden=true>;
            
                switch(formatFlag)
                {
                    case 6:
                         if(encryptionFlagCheck == 8194)
                         {
                             FSeek(streamInfoStart + 32);
                             uint16 encryptionFlag<name="Encryption flag", comment="always 8194">;   
                             ubyte unXORmagicNum<name="UnXOR magic number", comment="0 = not XOR'ed">;
                             
                             FSeek(streamInfoStart + 48);
                             uint32 oggPageTableSize<name="Ogg page table size">;
                             uint32 vorbisHeaderSize<name="Vorbis header size", comment="also applies for XOR'ed data">;
                             
                             FSeek(streamInfoStart + 64);
                             char oggPageTable[oggPageTableSize]<name="Ogg page table">;
                             char vorbisHeader[vorbisHeaderSize]<name="XOR'ed vorbis header", comment="not XOR'ed if magic number is 0">;
                         }
                         else
                         {
                            FSeek(streamInfoStart + 32);
                            char partialHeaderData[partialHeaderXORSize]<name="Vorbis Partial Header chunk">;
                         }
                         break;
                    
                    case 12:
                         FSeek(streamInfoStart + 32);
                         uint16 formatTag<name="ADPCM tag (always 2)">;
	                     uint16 channelCount<name="ADPCM Channels">;

	                     uint32 sampleRate<name="ADPCM SampleRate">;
	                     uint32 averageBytesPerSample<name="ADPCM Average Bytes Per Sample">;

	                     uint16 blockAlign<name="ADPCM Block Align">;
	                     uint16 bitsPerSample<name="ADPCM Bits Per Sample">;
	                     uint16 cbSize<name="ADPCM cbSize">;
	                     uint16 samplesPerBlock<name="ADPCM Samples Per Block">;
	                     uint16 numOfCoef<name="ADPCM number of entries in Coefficients">;

                         char adpcmCoefs[28]<name="ADPCM Array of Compression Coefficients">;                   
                         break;
                }
                        
                FSeek(streamInfoStart + 32 + partialHeaderXORSize);
                char streamData[streamSize]<name="Audio Stream">;
            }
            
            streamInfoSeek += 4;    
      
        }StreamInfo<name="'Stream-info'">;
    }


    local uint chunkCseek = chunkCtableOffset;
    local uint readValHolder = 255;

    while(readValHolder != 0)
    {
        FSeek(chunkCseek);
        uint32 testStartValue<hidden=true>;
        readValHolder = testStartValue;

        if(readValHolder != 0)
        {
            struct CHUNKC
            {
                FSeek(chunkCseek);
                uint32 chunkCstart<name="'Chunk-C' start">;
            
                FSeek(chunkCstart); 
                uint16 chunkC_unk1<name="uint16_UnknownValue_1">;
            
                chunkCseek += 4;  
            
            }chunkC<name="'Chunk-C'">;
        }      
    }


    typedef struct CHUNKD
    {
        uint32 chunkDstart<name="'Chunk-D' start">;

        FSeek(chunkDstart);            
        uint16 chunkD_unk1<name="uint16_UnknownValue_1">;
         
    }ChunkD<name="'Chunk-D'">;


    FSeek(chunkDtableOffset);
    ChunkD chunkDoffsets<name="'Chunk-D'">;


}File<open=true, name="FF13 SCD">;